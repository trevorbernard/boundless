// Copyright 2025 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Staking position tracking and rewards computation.

use alloy::primitives::{Address, U256};
use std::collections::{HashMap, HashSet};

/// Types of staking events from the blockchain
#[derive(Debug, Clone)]
pub enum StakeEvent {
    Created { owner: Address, amount: U256 },
    Added { owner: Address, new_total: U256 },
    UnstakeInitiated { owner: Address },
    UnstakeCompleted { owner: Address },
    RewardDelegateChanged { delegator: Address, new_delegate: Address },
    VoteDelegateChanged { delegator: Address, new_delegate: Address },
}

/// Staking event with block timestamp and epoch information
#[derive(Debug, Clone)]
pub struct TimestampedStakeEvent {
    pub block_number: u64,
    pub block_timestamp: u64,
    pub transaction_index: u64,
    pub log_index: u64,
    pub epoch: u64,
    pub event: StakeEvent,
}

/// Represents a staking position with delegation information
#[derive(Debug, Clone)]
pub struct StakingPosition {
    /// Amount of tokens staked
    pub staked_amount: U256,
    /// Whether the stake is being withdrawn
    pub is_withdrawing: bool,
    /// Address to whom rewards are delegated
    pub rewards_delegated_to: Option<Address>,
    /// Address to whom voting power is delegated
    pub votes_delegated_to: Option<Address>,
    /// Rewards generated by this position (regardless of delegation)
    pub rewards_generated: U256,
}

/// Information about rewards actually received by an address in an epoch
/// This represents the actual recipient of rewards (could be via delegation)
#[derive(Debug, Clone)]
pub struct StakerRewardInfo {
    /// Address that received the rewards
    pub staker_address: Address,
    /// Staking power (veZKC balance) that generated these rewards
    pub staking_power: U256,
    /// Rewards actually received by this address
    pub rewards_earned: U256,
    /// Percentage of total rewards received
    pub percentage: f64,
}

/// Complete staking data for a single epoch (positions + rewards)
#[derive(Debug, Clone)]
pub struct EpochStakingData {
    /// The epoch number
    pub epoch: u64,
    /// Staking positions by staker address (tracks who owns positions and rewards generated)
    pub positions_by_staker: HashMap<Address, StakingPosition>,
    /// Total staked amount in this epoch
    pub total_staked: U256,
    /// Number of active stakers
    pub num_stakers: usize,
    /// Number of stakers in withdrawal
    pub num_withdrawing: usize,
    /// Total staking emissions for this epoch
    pub total_staking_emissions: U256,
    /// Total staking power in this epoch
    pub total_staking_power: U256,
    /// Rewards by recipient address (tracks who actually received rewards)
    pub rewards_by_address: HashMap<Address, StakerRewardInfo>,
    /// Number of participants who earned rewards
    pub num_reward_recipients: usize,
}

/// Aggregate data for a single staker across all epochs
#[derive(Debug, Clone)]
pub struct StakerAggregate {
    /// Staker address
    pub staker_address: Address,
    /// Current staked amount (latest epoch)
    pub current_staked: U256,
    /// Whether currently withdrawing
    pub is_withdrawing: bool,
    /// Current rewards delegate
    pub rewards_delegated_to: Option<Address>,
    /// Current votes delegate
    pub votes_delegated_to: Option<Address>,
    /// Total rewards generated by positions owned by this address
    pub total_rewards_generated: U256,
    /// Total rewards actually received by this address (from own positions or delegations)
    pub total_rewards_earned: U256,
    /// Number of epochs participated in
    pub epochs_participated: u64,
}

/// Summary statistics across all epochs
#[derive(Debug, Clone)]
pub struct StakingSummary {
    /// Total staked amount in the latest epoch
    pub current_total_staked: U256,
    /// Total unique stakers ever
    pub total_unique_stakers: usize,
    /// Current number of active stakers
    pub current_active_stakers: usize,
    /// Current number of stakers withdrawing
    pub current_withdrawing: usize,
    /// Total staking emissions across all epochs
    pub total_staking_emissions_all_time: U256,
    /// Total unique reward recipients across all epochs
    pub total_unique_reward_recipients: usize,
}

/// Complete result of staking data computation
#[derive(Debug, Clone)]
pub struct StakingDataResult {
    /// Staking data by epoch
    pub epochs: Vec<EpochStakingData>,
    /// Aggregate data by staker
    pub staker_aggregates: HashMap<Address, StakerAggregate>,
    /// Summary statistics
    pub summary: StakingSummary,
}

/// Compute all staking data (positions and rewards) for all epochs
pub fn compute_staking_data(
    current_epoch: u64,
    processing_end_epoch: u64,
    timestamped_stake_events: &[TimestampedStakeEvent],
    staking_emissions_by_epoch: &HashMap<u64, U256>,
    staking_power_by_address_by_epoch: &HashMap<(Address, u64), U256>,
    total_staking_power_by_epoch: &HashMap<u64, U256>,
) -> anyhow::Result<StakingDataResult> {
    // First compute positions for all epochs
    let positions_by_epoch =
        compute_positions(timestamped_stake_events, current_epoch, processing_end_epoch)?;

    // Now compute rewards and combine with positions
    let mut epochs = Vec::new();
    let mut staker_aggregates: HashMap<Address, StakerAggregate> = HashMap::new();

    // Track statistics
    let mut all_stakers_ever = HashSet::new();
    let mut all_reward_recipients_ever = HashSet::new();
    let mut total_staking_emissions_all_time = U256::ZERO;

    for mut epoch_positions in positions_by_epoch {
        let epoch = epoch_positions.epoch;

        // Get emissions for this epoch
        let staking_emissions =
            staking_emissions_by_epoch.get(&epoch).copied().unwrap_or(U256::ZERO);

        // Get total staking power
        let total_staking_power =
            total_staking_power_by_epoch.get(&epoch).copied().unwrap_or(U256::ZERO);

        // Compute rewards for this epoch
        let mut rewards_by_recipient = HashMap::new();

        if staking_emissions > U256::ZERO {
            // First: Calculate rewards GENERATED by each position based on staked amount
            // This shows the value created by each position regardless of delegation
            if epoch_positions.total_staked > U256::ZERO {
                for position in epoch_positions.positions.values_mut() {
                    if position.staked_amount > U256::ZERO {
                        // Rewards generated based on position's stake proportion
                        position.rewards_generated = (position.staked_amount * staking_emissions)
                            / epoch_positions.total_staked;
                    }
                }
            }

            // Second: Determine who RECEIVES the rewards using staking power
            // Staking power accounts for delegations (delegator has 0, delegate has sum)
            if total_staking_power > U256::ZERO {
                for ((staker_address, staker_epoch), staking_power) in
                    staking_power_by_address_by_epoch
                {
                    if *staker_epoch == epoch && *staking_power > U256::ZERO {
                        // Calculate rewards to receive based on staking power
                        let rewards_to_receive =
                            (*staking_power * staking_emissions) / total_staking_power;

                        // Find who actually receives these rewards
                        // Note: The staker with staking_power might be receiving delegated rewards
                        let recipient_info = rewards_by_recipient
                            .entry(*staker_address)
                            .or_insert_with(|| StakerRewardInfo {
                                staker_address: *staker_address,
                                staking_power: U256::ZERO,
                                rewards_earned: U256::ZERO,
                                percentage: 0.0,
                            });
                        recipient_info.staking_power += staking_power;
                        recipient_info.rewards_earned += rewards_to_receive;

                        all_reward_recipients_ever.insert(*staker_address);
                    }
                }

                // Calculate percentages for recipients
                for recipient_info in rewards_by_recipient.values_mut() {
                    recipient_info.percentage = (recipient_info.staking_power * U256::from(10000)
                        / total_staking_power)
                        .to::<u64>() as f64
                        / 100.0;
                }
            }
        }

        // Track all stakers from positions
        for address in epoch_positions.positions.keys() {
            all_stakers_ever.insert(*address);
        }

        // Update aggregates
        for (address, position) in &epoch_positions.positions {
            let aggregate = staker_aggregates.entry(*address).or_insert_with(|| StakerAggregate {
                staker_address: *address,
                current_staked: U256::ZERO,
                is_withdrawing: false,
                rewards_delegated_to: None,
                votes_delegated_to: None,
                total_rewards_generated: U256::ZERO,
                total_rewards_earned: U256::ZERO,
                epochs_participated: 0,
            });

            // Update with latest position data (since we process epochs in order)
            aggregate.current_staked = position.staked_amount;
            aggregate.is_withdrawing = position.is_withdrawing;
            aggregate.rewards_delegated_to = position.rewards_delegated_to;
            aggregate.votes_delegated_to = position.votes_delegated_to;
            aggregate.total_rewards_generated += position.rewards_generated;
            aggregate.epochs_participated += 1;
        }

        // Update aggregates from reward recipients (tracks who actually received rewards)
        for (recipient_address, reward_info) in &rewards_by_recipient {
            // Ensure recipient has an aggregate entry (they may only be receiving delegated rewards)
            let aggregate =
                staker_aggregates.entry(*recipient_address).or_insert_with(|| StakerAggregate {
                    staker_address: *recipient_address,
                    current_staked: U256::ZERO,
                    is_withdrawing: false,
                    rewards_delegated_to: None,
                    votes_delegated_to: None,
                    total_rewards_generated: U256::ZERO,
                    total_rewards_earned: U256::ZERO,
                    epochs_participated: 0,
                });

            // Add earned rewards (these are rewards actually received)
            aggregate.total_rewards_earned += reward_info.rewards_earned;
        }

        total_staking_emissions_all_time += staking_emissions;

        // Create combined epoch data
        let num_reward_recipients = rewards_by_recipient.len();
        epochs.push(EpochStakingData {
            epoch,
            positions_by_staker: epoch_positions.positions,
            total_staked: epoch_positions.total_staked,
            num_stakers: epoch_positions.num_stakers,
            num_withdrawing: epoch_positions.num_withdrawing,
            total_staking_emissions: staking_emissions,
            total_staking_power,
            rewards_by_address: rewards_by_recipient,
            num_reward_recipients,
        });
    }

    // Get latest epoch data for current stats
    let latest_epoch = epochs.last().ok_or_else(|| anyhow::anyhow!("No epoch data computed"))?;

    let summary = StakingSummary {
        current_total_staked: latest_epoch.total_staked,
        total_unique_stakers: all_stakers_ever.len(),
        current_active_stakers: latest_epoch.num_stakers,
        current_withdrawing: latest_epoch.num_withdrawing,
        total_staking_emissions_all_time,
        total_unique_reward_recipients: all_reward_recipients_ever.len(),
    };

    Ok(StakingDataResult { epochs, staker_aggregates, summary })
}

/// Structure for position computation
#[derive(Debug, Clone)]
pub struct EpochStakingPositions {
    pub epoch: u64,
    pub positions: HashMap<Address, StakingPosition>,
    pub total_staked: U256,
    pub num_stakers: usize,
    pub num_withdrawing: usize,
}

/// Compute staking positions from timestamped events
fn compute_positions(
    timestamped_events: &[TimestampedStakeEvent],
    _current_epoch: u64,
    processing_end_epoch: u64,
) -> anyhow::Result<Vec<EpochStakingPositions>> {
    // Tracking current state
    let mut current_stakes: HashMap<Address, U256> = HashMap::new();
    let mut current_withdrawing: HashMap<Address, bool> = HashMap::new();
    let mut current_vote_delegations: HashMap<Address, Address> = HashMap::new();
    let mut current_reward_delegations: HashMap<Address, Address> = HashMap::new();

    // Results by epoch
    let mut epoch_positions = Vec::new();
    let mut last_processed_epoch = None;

    // Process events in chronological order
    for event in timestamped_events {
        // Check if we've moved to a new epoch
        if last_processed_epoch.is_some() && Some(event.epoch) != last_processed_epoch {
            // Save snapshot for the previous epoch before moving on
            if let Some(prev_epoch) = last_processed_epoch {
                epoch_positions.push(create_epoch_snapshot(
                    prev_epoch,
                    &current_stakes,
                    &current_withdrawing,
                    &current_vote_delegations,
                    &current_reward_delegations,
                ));
            }
        }

        // Apply the event to update current state
        match &event.event {
            StakeEvent::Created { owner, amount } => {
                current_stakes.insert(*owner, *amount);
                current_withdrawing.insert(*owner, false);
            }
            StakeEvent::Added { owner, new_total } => {
                current_stakes.insert(*owner, *new_total);
            }
            StakeEvent::UnstakeInitiated { owner } => {
                current_withdrawing.insert(*owner, true);
            }
            StakeEvent::UnstakeCompleted { owner } => {
                current_stakes.remove(owner);
                current_withdrawing.remove(owner);
                current_vote_delegations.remove(owner);
                current_reward_delegations.remove(owner);
            }
            StakeEvent::RewardDelegateChanged { delegator, new_delegate } => {
                if *new_delegate == Address::ZERO {
                    current_reward_delegations.remove(delegator);
                } else {
                    current_reward_delegations.insert(*delegator, *new_delegate);
                }
            }
            StakeEvent::VoteDelegateChanged { delegator, new_delegate } => {
                if *new_delegate == Address::ZERO {
                    current_vote_delegations.remove(delegator);
                } else {
                    current_vote_delegations.insert(*delegator, *new_delegate);
                }
            }
        }

        last_processed_epoch = Some(event.epoch);
    }

    // Process any remaining epochs up to processing_end_epoch
    for epoch in last_processed_epoch.unwrap_or(0)..=processing_end_epoch {
        if epoch_positions.iter().any(|e| e.epoch == epoch) {
            continue; // Already processed
        }

        epoch_positions.push(create_epoch_snapshot(
            epoch,
            &current_stakes,
            &current_withdrawing,
            &current_vote_delegations,
            &current_reward_delegations,
        ));
    }

    // Sort by epoch to ensure chronological order
    epoch_positions.sort_by_key(|e| e.epoch);

    Ok(epoch_positions)
}

fn create_epoch_snapshot(
    epoch: u64,
    stakes: &HashMap<Address, U256>,
    withdrawing: &HashMap<Address, bool>,
    vote_delegations: &HashMap<Address, Address>,
    reward_delegations: &HashMap<Address, Address>,
) -> EpochStakingPositions {
    let mut positions = HashMap::new();
    let mut total_staked = U256::ZERO;
    let mut num_withdrawing = 0;

    for (address, amount) in stakes {
        let is_withdrawing = withdrawing.get(address).copied().unwrap_or(false);
        if is_withdrawing {
            num_withdrawing += 1;
        }

        positions.insert(
            *address,
            StakingPosition {
                staked_amount: *amount,
                is_withdrawing,
                rewards_delegated_to: reward_delegations.get(address).copied(),
                votes_delegated_to: vote_delegations.get(address).copied(),
                rewards_generated: U256::ZERO, // Will be calculated later when rewards are computed
            },
        );

        total_staked += amount;
    }

    let num_stakers = positions.len();
    EpochStakingPositions { epoch, positions, total_staked, num_stakers, num_withdrawing }
}

// ============================================================================
// Compatibility Functions (for gradual migration)
// ============================================================================

/// Legacy: Compute only staking positions (without rewards)
pub fn compute_staking_positions(
    timestamped_events: &[TimestampedStakeEvent],
    current_epoch: u64,
    processing_end_epoch: u64,
) -> anyhow::Result<StakingPositionsResult> {
    let positions = compute_positions(timestamped_events, current_epoch, processing_end_epoch)?;

    // Convert to legacy format
    let epoch_positions = positions
        .into_iter()
        .map(|p| EpochStakingPositions {
            epoch: p.epoch,
            positions: p.positions,
            total_staked: p.total_staked,
            num_stakers: p.num_stakers,
            num_withdrawing: p.num_withdrawing,
        })
        .collect::<Vec<_>>();

    // Get latest for summary
    let latest = epoch_positions.last().ok_or_else(|| anyhow::anyhow!("No epoch data"))?;

    // Count unique stakers
    let mut all_stakers = HashSet::new();
    for epoch in &epoch_positions {
        for address in epoch.positions.keys() {
            all_stakers.insert(*address);
        }
    }

    let summary = StakingSummary {
        current_total_staked: latest.total_staked,
        total_unique_stakers: all_stakers.len(),
        current_active_stakers: latest.num_stakers,
        current_withdrawing: latest.num_withdrawing,
        total_staking_emissions_all_time: U256::ZERO, // Not computed in legacy
        total_unique_reward_recipients: 0,            // Not computed in legacy
    };

    Ok(StakingPositionsResult { epoch_positions, summary })
}

/// Legacy result structure (kept for compatibility)
#[derive(Debug, Clone)]
pub struct StakingPositionsResult {
    pub epoch_positions: Vec<EpochStakingPositions>,
    pub summary: StakingSummary,
}

pub fn compute_staking_rewards(
    current_epoch: u64,
    processing_end_epoch: u64,
    staking_emissions_by_epoch: &HashMap<u64, U256>,
    staking_power_by_address_by_epoch: &HashMap<(Address, u64), U256>,
    total_staking_power_by_epoch: &HashMap<u64, U256>,
) -> anyhow::Result<StakingRewardsResult> {
    // Use the new unified function internally
    let data = compute_staking_data(
        current_epoch,
        processing_end_epoch,
        &[], // No events needed for just rewards
        staking_emissions_by_epoch,
        staking_power_by_address_by_epoch,
        total_staking_power_by_epoch,
    )?;

    // Convert to legacy format
    let epoch_rewards: Vec<EpochStakingRewards> = data
        .epochs
        .into_iter()
        .map(|e| EpochStakingRewards {
            epoch: e.epoch,
            total_staking_emissions: e.total_staking_emissions,
            total_staking_power: e.total_staking_power,
            rewards_by_staker: e.rewards_by_address,
            num_participants: e.num_reward_recipients,
        })
        .collect();

    let total_epochs = epoch_rewards.len();
    let summary = StakingRewardsSummary {
        total_epochs_with_rewards: total_epochs,
        total_unique_stakers: data.summary.total_unique_reward_recipients,
        total_staking_emissions_all_time: data.summary.total_staking_emissions_all_time,
    };

    Ok(StakingRewardsResult { epoch_rewards, summary })
}

/// Legacy: Rewards for a single epoch
#[derive(Debug, Clone)]
pub struct EpochStakingRewards {
    pub epoch: u64,
    pub total_staking_emissions: U256,
    pub total_staking_power: U256,
    pub rewards_by_staker: HashMap<Address, StakerRewardInfo>,
    pub num_participants: usize,
}

/// Legacy: Summary for rewards only
#[derive(Debug, Clone)]
pub struct StakingRewardsSummary {
    pub total_epochs_with_rewards: usize,
    pub total_unique_stakers: usize,
    pub total_staking_emissions_all_time: U256,
}

/// Legacy: Result structure for rewards
#[derive(Debug, Clone)]
pub struct StakingRewardsResult {
    pub epoch_rewards: Vec<EpochStakingRewards>,
    pub summary: StakingRewardsSummary,
}
